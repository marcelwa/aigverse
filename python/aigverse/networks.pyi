from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import networkx as nx
    import numpy as np

class AigNode:
    def __init__(self, index: int) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: AigNode | int) -> bool: ...

class AigSignal:
    def __init__(self, index: int, complement: bool) -> None: ...
    def get_index(self) -> int: ...
    def get_complement(self) -> bool: ...
    def get_data(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: AigSignal) -> bool: ...
    def __invert__(self) -> AigSignal: ...
    def __pos__(self) -> AigSignal: ...
    def __neg__(self) -> AigSignal: ...
    def __xor__(self, complement: bool) -> AigSignal: ...

class Aig:
    def __init__(self) -> None: ...
    def clone(self) -> Aig: ...
    def size(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def get_node(self, s: AigSignal) -> AigNode: ...
    def make_signal(self, n: AigNode | int) -> AigSignal: ...
    def is_complemented(self, s: AigSignal) -> bool: ...
    def node_to_index(self, n: AigNode | int) -> int: ...
    def index_to_node(self, index: int) -> AigNode: ...
    def pi_index(self, n: AigNode | int) -> int: ...
    def pi_at(self, index: int) -> AigNode: ...
    def po_index(self, s: AigSignal) -> int: ...
    def po_at(self, index: int) -> AigSignal: ...
    def get_constant(self, value: bool) -> AigSignal: ...
    def create_pi(self) -> AigSignal: ...
    def create_po(self, f: AigSignal) -> int: ...
    def is_combinational(self) -> bool: ...
    def create_buf(self, a: AigSignal) -> AigSignal: ...
    def create_not(self, a: AigSignal) -> AigSignal: ...
    def create_and(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_nand(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_or(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_nor(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_xor(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_xnor(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_lt(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_le(self, a: AigSignal, b: AigSignal) -> AigSignal: ...
    def create_maj(self, a: AigSignal, b: AigSignal, c: AigSignal) -> AigSignal: ...
    def create_ite(self, cond: AigSignal, f_then: AigSignal, f_else: AigSignal) -> AigSignal: ...
    def create_xor3(self, a: AigSignal, b: AigSignal, c: AigSignal) -> AigSignal: ...
    def create_nary_and(self, fs: list[AigSignal]) -> AigSignal: ...
    def create_nary_or(self, fs: list[AigSignal]) -> AigSignal: ...
    def create_nary_xor(self, fs: list[AigSignal]) -> AigSignal: ...
    def clone_node(self, other: Aig, source: AigNode | int, children: list[AigSignal]) -> AigSignal: ...
    def nodes(self) -> list[AigNode]: ...
    def gates(self) -> list[AigNode]: ...
    def pis(self) -> list[AigNode]: ...
    def pos(self) -> list[AigSignal]: ...
    def fanins(self, n: AigNode | int) -> list[AigSignal]: ...
    def fanin_size(self, n: AigNode | int) -> int: ...
    def fanout_size(self, n: AigNode | int) -> int: ...
    def is_constant(self, n: AigNode | int) -> bool: ...
    def is_pi(self, n: AigNode | int) -> bool: ...
    def has_and(self, a: AigSignal, b: AigSignal) -> bool: ...
    def is_and(self, n: AigNode | int) -> bool: ...
    def is_or(self, n: AigNode | int) -> bool: ...
    def is_xor(self, n: AigNode | int) -> bool: ...
    def is_maj(self, n: AigNode | int) -> bool: ...
    def is_ite(self, n: AigNode | int) -> bool: ...
    def is_xor3(self, n: AigNode | int) -> bool: ...
    def is_nary_and(self, n: AigNode | int) -> bool: ...
    def is_nary_or(self, n: AigNode | int) -> bool: ...
    def __getstate__(self) -> tuple[list[int]]: ...
    def __setstate__(self, state: tuple[list[int]]) -> Aig: ...
    def cleanup_dangling(self) -> None: ...
    if TYPE_CHECKING:
        def to_networkx(
            self,
            *,
            levels: bool = False,
            fanouts: bool = False,
            node_tts: bool = False,
            graph_tts: bool = False,
            dtype: type[np.generic] = ...,
        ) -> nx.DiGraph: ...

class NamedAig(Aig):
    def __init__(self, ntk: Aig | NamedAig | None = None) -> None: ...
    def create_pi(self, name: str = "") -> AigSignal: ...
    def create_po(self, f: AigSignal, name: str = "") -> int: ...
    def set_network_name(self, name: str) -> None: ...
    def get_network_name(self) -> str: ...
    def has_name(self, s: AigSignal) -> bool: ...
    def set_name(self, s: AigSignal, name: str) -> None: ...
    def get_name(self, s: AigSignal) -> str: ...
    def has_output_name(self, index: int) -> bool: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...

class DepthAig(Aig):
    def __init__(self, ntk: Aig | DepthAig | None = None) -> None: ...
    def num_levels(self) -> int: ...
    def level(self, n: AigNode | int) -> int: ...
    def is_on_critical_path(self, n: AigNode | int) -> bool: ...
    def update_levels(self) -> None: ...
    def create_po(self, f: AigSignal) -> int: ...

class FanoutAig(Aig):
    def __init__(self, ntk: Aig | FanoutAig | None = None) -> None: ...
    def fanouts(self, n: AigNode | int) -> list[AigNode]: ...

class AigRegister:
    def __init__(self, register: AigRegister | None = None) -> None: ...
    control: str
    init: int
    type: str

class SequentialAig(Aig):
    def __init__(self) -> None: ...
    def create_pi(self) -> AigSignal: ...
    def create_po(self, f: AigSignal) -> int: ...
    def create_ro(self) -> AigSignal: ...
    def create_ri(self, f: AigSignal) -> int: ...
    def is_combinational(self) -> bool: ...
    def is_ci(self, n: AigNode | int) -> bool: ...
    def is_pi(self, n: AigNode | int) -> bool: ...
    def is_ro(self, n: AigNode | int) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_cis(self) -> int: ...
    def num_cos(self) -> int: ...
    def num_registers(self) -> int: ...
    def pi_at(self, index: int) -> AigNode: ...
    def po_at(self, index: int) -> AigSignal: ...
    def ci_at(self, index: int) -> AigNode: ...
    def co_at(self, index: int) -> AigSignal: ...
    def ro_at(self, index: int) -> AigNode: ...
    def ri_at(self, index: int) -> AigSignal: ...
    def set_register(self, index: int, register: AigRegister) -> None: ...
    def register_at(self, index: int) -> AigRegister: ...
    def pi_index(self, n: AigNode | int) -> int: ...
    def ci_index(self, n: AigNode | int) -> int: ...
    def co_index(self, s: AigSignal) -> int: ...
    def ro_index(self, n: AigNode | int) -> int: ...
    def ri_index(self, s: AigSignal) -> int: ...
    def ro_to_ri(self, ro: AigSignal) -> AigSignal: ...
    def ri_to_ro(self, ri: AigSignal) -> AigNode: ...
    def pis(self) -> list[AigNode]: ...
    def pos(self) -> list[AigSignal]: ...
    def cis(self) -> list[AigNode]: ...
    def cos(self) -> list[AigSignal]: ...
    def ros(self) -> list[AigNode]: ...
    def ris(self) -> list[AigSignal]: ...
    def registers(self) -> list[tuple[AigSignal, AigNode]]: ...
