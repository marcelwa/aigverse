from collections.abc import Iterator
from typing import Any, overload

from . import networks

class AigEdge:
    source: int | networks.AigNode
    target: int | networks.AigNode
    weight: int
    @overload
    def __init__(self, source: int | networks.AigNode, target: int | networks.AigNode, weight: int = 0) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class AigEdgeList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ntk: networks.Aig) -> None: ...
    @overload
    def __init__(self, ntk: networks.Aig, edges: list[AigEdge]) -> None: ...
    ntk: networks.Aig
    edges: list[AigEdge]
    def append(self, edge: AigEdge) -> None: ...
    def clear(self) -> None: ...
    def size(self) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def __iter__(self) -> Iterator[AigEdge]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> AigEdge: ...
    def __setitem__(self, index: int, edge: AigEdge) -> None: ...
    def raw(self) -> list[tuple[int, int, int]]: ...

class AigIndexList:
    @overload
    def __init__(self, num_pis: int = 0) -> None: ...
    @overload
    def __init__(self, values: list[int]) -> None: ...
    def raw(self) -> list[int]: ...
    def size(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def add_inputs(self, n: int = 1) -> None: ...
    def add_and(self, lit0: int, lit1: int) -> None: ...
    def add_xor(self, lit0: int, lit1: int) -> None: ...
    def add_output(self, lit: int) -> None: ...
    def clear(self) -> None: ...
    def gates(self) -> list[tuple[int, int]]: ...
    def pos(self) -> list[int]: ...
    def __iter__(self) -> Iterator[int]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: int) -> None: ...
    def __len__(self) -> int: ...

def to_edge_list(
    ntk: networks.Aig | networks.SequentialAig, regular_weight: int = 0, inverted_weight: int = 1
) -> AigEdgeList: ...
def to_index_list(ntk: networks.Aig) -> AigIndexList: ...
def to_aig(il: AigIndexList) -> networks.Aig: ...

class TruthTable:
    def __init__(self, num_vars: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: TruthTable) -> bool: ...
    def __and__(self, other: TruthTable) -> TruthTable: ...
    def __or__(self, other: TruthTable) -> TruthTable: ...
    def __xor__(self, other: TruthTable) -> TruthTable: ...
    def __invert__(self) -> TruthTable: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: bool) -> None: ...
    def __iter__(self) -> Iterator[bool]: ...
    def num_vars(self) -> int: ...
    def num_blocks(self) -> int: ...
    def num_bits(self) -> int: ...
    def __copy__(self) -> TruthTable: ...
    def __deepcopy__(self, memo: dict[Any, Any]) -> TruthTable: ...
    def __assign__(self, other: TruthTable) -> TruthTable: ...
    def __hash__(self) -> int: ...
    def __getstate__(self) -> tuple[int, list[int]]: ...
    def __setstate__(self, state: tuple[int, list[int]]) -> None: ...
    def set_bit(self, index: int) -> None: ...
    def get_bit(self, index: int) -> bool: ...
    def clear_bit(self, index: int) -> None: ...
    def flip_bit(self, index: int) -> None: ...
    def get_block(self, block_index: int) -> int: ...
    def create_nth_var(self, var_index: int, complement: bool = False) -> None: ...
    def create_from_binary_string(self, binary: str) -> None: ...
    def create_from_hex_string(self, hexadecimal: str) -> None: ...
    def create_random(self) -> None: ...
    def create_majority(self) -> None: ...
    def clear(self) -> None: ...
    def count_ones(self) -> int: ...
    def count_zeroes(self) -> int: ...
    def is_const0(self) -> bool: ...
    def is_const1(self) -> bool: ...
    def to_binary(self) -> str: ...
    def to_hex(self) -> str: ...

def ternary_majority(a: TruthTable, b: TruthTable, c: TruthTable) -> TruthTable: ...
def cofactor0(tt: TruthTable, var_index: int) -> TruthTable: ...
def cofactor1(tt: TruthTable, var_index: int) -> TruthTable: ...
